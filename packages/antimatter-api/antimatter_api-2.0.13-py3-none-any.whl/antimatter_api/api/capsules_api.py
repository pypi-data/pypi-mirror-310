# coding: utf-8

"""
    Antimatter Public API

    Interact with the Antimatter Cloud API

    The version of the OpenAPI document: 2.0.13
    Contact: support@antimatter.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from antimatter_api.models.access_log_results import AccessLogResults
from antimatter_api.models.capsule_info import CapsuleInfo
from antimatter_api.models.capsule_list import CapsuleList
from antimatter_api.models.delete_tags import DeleteTags
from antimatter_api.models.domain_tag_info_results import DomainTagInfoResults
from antimatter_api.models.domain_upsert_capsule_tags_request import DomainUpsertCapsuleTagsRequest
from antimatter_api.models.error import Error

from antimatter_api.api_client import ApiClient, RequestSerialized
from antimatter_api.api_response import ApiResponse
from antimatter_api.rest import RESTResponseType


class CapsulesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def capsule_get_by_id(
        self,
        capsule_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Error:
        """Get a Capsule by ID

        This endpoint allows you to get a Capsule without knowing the Domain ID. It will redirect the user to the full `/domains/{domainID}/capsules/{capsuleID}` path. 

        :param capsule_id: (required)
        :type capsule_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._capsule_get_by_id_serialize(
            capsule_id=capsule_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '301': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def capsule_get_by_id_with_http_info(
        self,
        capsule_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Error]:
        """Get a Capsule by ID

        This endpoint allows you to get a Capsule without knowing the Domain ID. It will redirect the user to the full `/domains/{domainID}/capsules/{capsuleID}` path. 

        :param capsule_id: (required)
        :type capsule_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._capsule_get_by_id_serialize(
            capsule_id=capsule_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '301': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def capsule_get_by_id_without_preload_content(
        self,
        capsule_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a Capsule by ID

        This endpoint allows you to get a Capsule without knowing the Domain ID. It will redirect the user to the full `/domains/{domainID}/capsules/{capsuleID}` path. 

        :param capsule_id: (required)
        :type capsule_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._capsule_get_by_id_serialize(
            capsule_id=capsule_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '301': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _capsule_get_by_id_serialize(
        self,
        capsule_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if capsule_id is not None:
            _path_params['capsuleID'] = capsule_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/capsules/{capsuleID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_delete_capsule_tags(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        delete_tags: DeleteTags,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete capsule-level tags

        Delete capsule-level tags

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param delete_tags: (required)
        :type delete_tags: DeleteTags
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_delete_capsule_tags_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            delete_tags=delete_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_delete_capsule_tags_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        delete_tags: DeleteTags,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete capsule-level tags

        Delete capsule-level tags

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param delete_tags: (required)
        :type delete_tags: DeleteTags
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_delete_capsule_tags_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            delete_tags=delete_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_delete_capsule_tags_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        delete_tags: DeleteTags,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete capsule-level tags

        Delete capsule-level tags

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param delete_tags: (required)
        :type delete_tags: DeleteTags
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_delete_capsule_tags_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            delete_tags=delete_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_delete_capsule_tags_serialize(
        self,
        domain_id,
        capsule_id,
        delete_tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        if capsule_id is not None:
            _path_params['capsuleID'] = capsule_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_tags is not None:
            _body_params = delete_tags


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/domains/{domainID}/capsules/{capsuleID}/capsule-tags/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_get_capsule_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CapsuleInfo:
        """Get capsule info

        Get the summary information about this capsule 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_get_capsule_info_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CapsuleInfo",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_get_capsule_info_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CapsuleInfo]:
        """Get capsule info

        Get the summary information about this capsule 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_get_capsule_info_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CapsuleInfo",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_get_capsule_info_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get capsule info

        Get the summary information about this capsule 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_get_capsule_info_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CapsuleInfo",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_get_capsule_info_serialize(
        self,
        domain_id,
        capsule_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        if capsule_id is not None:
            _path_params['capsuleID'] = capsule_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/domains/{domainID}/capsules/{capsuleID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_get_tag_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DomainTagInfoResults:
        """Get an ordered list of the top 100 tags.

        Get an ordered list of the top 100 tags. The ordering is: - Tags emitted by hooks - Tags referenced in read context rules - Capsule and span tags that appear in the capsule manifest ordered by number of appearances This list will be truncated (and `has_more` will be true) if the above yields more than 100 tags. There is currently no endpoint to receive a complete list of tags. 

        :param domain_id: (required)
        :type domain_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_get_tag_info_serialize(
            domain_id=domain_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DomainTagInfoResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_get_tag_info_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DomainTagInfoResults]:
        """Get an ordered list of the top 100 tags.

        Get an ordered list of the top 100 tags. The ordering is: - Tags emitted by hooks - Tags referenced in read context rules - Capsule and span tags that appear in the capsule manifest ordered by number of appearances This list will be truncated (and `has_more` will be true) if the above yields more than 100 tags. There is currently no endpoint to receive a complete list of tags. 

        :param domain_id: (required)
        :type domain_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_get_tag_info_serialize(
            domain_id=domain_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DomainTagInfoResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_get_tag_info_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an ordered list of the top 100 tags.

        Get an ordered list of the top 100 tags. The ordering is: - Tags emitted by hooks - Tags referenced in read context rules - Capsule and span tags that appear in the capsule manifest ordered by number of appearances This list will be truncated (and `has_more` will be true) if the above yields more than 100 tags. There is currently no endpoint to receive a complete list of tags. 

        :param domain_id: (required)
        :type domain_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_get_tag_info_serialize(
            domain_id=domain_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DomainTagInfoResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_get_tag_info_serialize(
        self,
        domain_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/domains/{domainID}/tag-info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_list_capsules(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        span_tags: Annotated[Optional[StrictStr], Field(description="the span tags you would like to filter on. This accepts a tag key only and will return all span tag key  results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        sort_on: Annotated[Optional[StrictStr], Field(description="the capsule field you would like to sort on. This accepts the field only and will return results ordered on the provided field. If not specified, this field is ignored. ")] = None,
        start_after: Annotated[Optional[StrictStr], Field(description="the pagination key you would like to retrieve results after. This accepts the pagination key only and works in combination with the sort_on parameter to return records strictly after the provided pagination key. If not  specified, this field is ignored. ")] = None,
        ascending: Annotated[Optional[StrictBool], Field(description="the defines whether a sorted result should be order ascending. This accepts a boolean value and when true will work in combination with the sort_on and start_after parameters to return values in ascending order. If not  specified, this field is ignored and treated as false. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CapsuleList:
        """Get capsule list

        Get information about capsules 

        :param domain_id: (required)
        :type domain_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param span_tags: the span tags you would like to filter on. This accepts a tag key only and will return all span tag key  results matching the provided tag key. If not specified, this field is ignored. 
        :type span_tags: str
        :param sort_on: the capsule field you would like to sort on. This accepts the field only and will return results ordered on the provided field. If not specified, this field is ignored. 
        :type sort_on: str
        :param start_after: the pagination key you would like to retrieve results after. This accepts the pagination key only and works in combination with the sort_on parameter to return records strictly after the provided pagination key. If not  specified, this field is ignored. 
        :type start_after: str
        :param ascending: the defines whether a sorted result should be order ascending. This accepts a boolean value and when true will work in combination with the sort_on and start_after parameters to return values in ascending order. If not  specified, this field is ignored and treated as false. 
        :type ascending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_list_capsules_serialize(
            domain_id=domain_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            span_tags=span_tags,
            sort_on=sort_on,
            start_after=start_after,
            ascending=ascending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CapsuleList",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_list_capsules_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        span_tags: Annotated[Optional[StrictStr], Field(description="the span tags you would like to filter on. This accepts a tag key only and will return all span tag key  results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        sort_on: Annotated[Optional[StrictStr], Field(description="the capsule field you would like to sort on. This accepts the field only and will return results ordered on the provided field. If not specified, this field is ignored. ")] = None,
        start_after: Annotated[Optional[StrictStr], Field(description="the pagination key you would like to retrieve results after. This accepts the pagination key only and works in combination with the sort_on parameter to return records strictly after the provided pagination key. If not  specified, this field is ignored. ")] = None,
        ascending: Annotated[Optional[StrictBool], Field(description="the defines whether a sorted result should be order ascending. This accepts a boolean value and when true will work in combination with the sort_on and start_after parameters to return values in ascending order. If not  specified, this field is ignored and treated as false. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CapsuleList]:
        """Get capsule list

        Get information about capsules 

        :param domain_id: (required)
        :type domain_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param span_tags: the span tags you would like to filter on. This accepts a tag key only and will return all span tag key  results matching the provided tag key. If not specified, this field is ignored. 
        :type span_tags: str
        :param sort_on: the capsule field you would like to sort on. This accepts the field only and will return results ordered on the provided field. If not specified, this field is ignored. 
        :type sort_on: str
        :param start_after: the pagination key you would like to retrieve results after. This accepts the pagination key only and works in combination with the sort_on parameter to return records strictly after the provided pagination key. If not  specified, this field is ignored. 
        :type start_after: str
        :param ascending: the defines whether a sorted result should be order ascending. This accepts a boolean value and when true will work in combination with the sort_on and start_after parameters to return values in ascending order. If not  specified, this field is ignored and treated as false. 
        :type ascending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_list_capsules_serialize(
            domain_id=domain_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            span_tags=span_tags,
            sort_on=sort_on,
            start_after=start_after,
            ascending=ascending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CapsuleList",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_list_capsules_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        span_tags: Annotated[Optional[StrictStr], Field(description="the span tags you would like to filter on. This accepts a tag key only and will return all span tag key  results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        sort_on: Annotated[Optional[StrictStr], Field(description="the capsule field you would like to sort on. This accepts the field only and will return results ordered on the provided field. If not specified, this field is ignored. ")] = None,
        start_after: Annotated[Optional[StrictStr], Field(description="the pagination key you would like to retrieve results after. This accepts the pagination key only and works in combination with the sort_on parameter to return records strictly after the provided pagination key. If not  specified, this field is ignored. ")] = None,
        ascending: Annotated[Optional[StrictBool], Field(description="the defines whether a sorted result should be order ascending. This accepts a boolean value and when true will work in combination with the sort_on and start_after parameters to return values in ascending order. If not  specified, this field is ignored and treated as false. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get capsule list

        Get information about capsules 

        :param domain_id: (required)
        :type domain_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param span_tags: the span tags you would like to filter on. This accepts a tag key only and will return all span tag key  results matching the provided tag key. If not specified, this field is ignored. 
        :type span_tags: str
        :param sort_on: the capsule field you would like to sort on. This accepts the field only and will return results ordered on the provided field. If not specified, this field is ignored. 
        :type sort_on: str
        :param start_after: the pagination key you would like to retrieve results after. This accepts the pagination key only and works in combination with the sort_on parameter to return records strictly after the provided pagination key. If not  specified, this field is ignored. 
        :type start_after: str
        :param ascending: the defines whether a sorted result should be order ascending. This accepts a boolean value and when true will work in combination with the sort_on and start_after parameters to return values in ascending order. If not  specified, this field is ignored and treated as false. 
        :type ascending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_list_capsules_serialize(
            domain_id=domain_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            span_tags=span_tags,
            sort_on=sort_on,
            start_after=start_after,
            ascending=ascending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CapsuleList",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_list_capsules_serialize(
        self,
        domain_id,
        start_date,
        end_date,
        num_results,
        span_tags,
        sort_on,
        start_after,
        ascending,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if num_results is not None:
            
            _query_params.append(('num_results', num_results))
            
        if span_tags is not None:
            
            _query_params.append(('span_tags', span_tags))
            
        if sort_on is not None:
            
            _query_params.append(('sort_on', sort_on))
            
        if start_after is not None:
            
            _query_params.append(('start_after', start_after))
            
        if ascending is not None:
            
            _query_params.append(('ascending', ascending))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/domains/{domainID}/capsules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_query_access_log(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        start_from_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. ")] = None,
        session: Annotated[Optional[StrictStr], Field(description="the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. ")] = None,
        location: Annotated[Optional[StrictStr], Field(description="the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. ")] = None,
        location_prefixed: Annotated[Optional[StrictBool], Field(description="a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. ")] = None,
        operation_type: Annotated[Optional[StrictStr], Field(description="the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. ")] = None,
        allowed_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        redacted_or_tokenized_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccessLogResults:
        """Get the domain data-plane audit log

        Query the data access log for this domain. This contains all operations interacting with capsules within this domain. Results are returned in reverse chronological order 

        :param domain_id: (required)
        :type domain_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param start_from_id: which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. 
        :type start_from_id: str
        :param session: the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. 
        :type session: str
        :param location: the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. 
        :type location: str
        :param location_prefixed: a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. 
        :type location_prefixed: bool
        :param operation_type: the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. 
        :type operation_type: str
        :param allowed_tag: the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. 
        :type allowed_tag: str
        :param redacted_or_tokenized_tag: the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. 
        :type redacted_or_tokenized_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_query_access_log_serialize(
            domain_id=domain_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            start_from_id=start_from_id,
            session=session,
            location=location,
            location_prefixed=location_prefixed,
            operation_type=operation_type,
            allowed_tag=allowed_tag,
            redacted_or_tokenized_tag=redacted_or_tokenized_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessLogResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_query_access_log_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        start_from_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. ")] = None,
        session: Annotated[Optional[StrictStr], Field(description="the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. ")] = None,
        location: Annotated[Optional[StrictStr], Field(description="the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. ")] = None,
        location_prefixed: Annotated[Optional[StrictBool], Field(description="a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. ")] = None,
        operation_type: Annotated[Optional[StrictStr], Field(description="the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. ")] = None,
        allowed_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        redacted_or_tokenized_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccessLogResults]:
        """Get the domain data-plane audit log

        Query the data access log for this domain. This contains all operations interacting with capsules within this domain. Results are returned in reverse chronological order 

        :param domain_id: (required)
        :type domain_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param start_from_id: which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. 
        :type start_from_id: str
        :param session: the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. 
        :type session: str
        :param location: the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. 
        :type location: str
        :param location_prefixed: a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. 
        :type location_prefixed: bool
        :param operation_type: the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. 
        :type operation_type: str
        :param allowed_tag: the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. 
        :type allowed_tag: str
        :param redacted_or_tokenized_tag: the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. 
        :type redacted_or_tokenized_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_query_access_log_serialize(
            domain_id=domain_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            start_from_id=start_from_id,
            session=session,
            location=location,
            location_prefixed=location_prefixed,
            operation_type=operation_type,
            allowed_tag=allowed_tag,
            redacted_or_tokenized_tag=redacted_or_tokenized_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessLogResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_query_access_log_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        start_from_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. ")] = None,
        session: Annotated[Optional[StrictStr], Field(description="the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. ")] = None,
        location: Annotated[Optional[StrictStr], Field(description="the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. ")] = None,
        location_prefixed: Annotated[Optional[StrictBool], Field(description="a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. ")] = None,
        operation_type: Annotated[Optional[StrictStr], Field(description="the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. ")] = None,
        allowed_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        redacted_or_tokenized_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the domain data-plane audit log

        Query the data access log for this domain. This contains all operations interacting with capsules within this domain. Results are returned in reverse chronological order 

        :param domain_id: (required)
        :type domain_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param start_from_id: which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. 
        :type start_from_id: str
        :param session: the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. 
        :type session: str
        :param location: the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. 
        :type location: str
        :param location_prefixed: a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. 
        :type location_prefixed: bool
        :param operation_type: the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. 
        :type operation_type: str
        :param allowed_tag: the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. 
        :type allowed_tag: str
        :param redacted_or_tokenized_tag: the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. 
        :type redacted_or_tokenized_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_query_access_log_serialize(
            domain_id=domain_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            start_from_id=start_from_id,
            session=session,
            location=location,
            location_prefixed=location_prefixed,
            operation_type=operation_type,
            allowed_tag=allowed_tag,
            redacted_or_tokenized_tag=redacted_or_tokenized_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessLogResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_query_access_log_serialize(
        self,
        domain_id,
        start_date,
        end_date,
        num_results,
        start_from_id,
        session,
        location,
        location_prefixed,
        operation_type,
        allowed_tag,
        redacted_or_tokenized_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if num_results is not None:
            
            _query_params.append(('num_results', num_results))
            
        if start_from_id is not None:
            
            _query_params.append(('start_from_id', start_from_id))
            
        if session is not None:
            
            _query_params.append(('session', session))
            
        if location is not None:
            
            _query_params.append(('location', location))
            
        if location_prefixed is not None:
            
            _query_params.append(('location_prefixed', location_prefixed))
            
        if operation_type is not None:
            
            _query_params.append(('operation_type', operation_type))
            
        if allowed_tag is not None:
            
            _query_params.append(('allowed_tag', allowed_tag))
            
        if redacted_or_tokenized_tag is not None:
            
            _query_params.append(('redacted_or_tokenized_tag', redacted_or_tokenized_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/domains/{domainID}/log',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_query_access_log_single_capsule(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        start_from_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. ")] = None,
        session: Annotated[Optional[StrictStr], Field(description="the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. ")] = None,
        location: Annotated[Optional[StrictStr], Field(description="the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. ")] = None,
        location_prefixed: Annotated[Optional[StrictBool], Field(description="a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. ")] = None,
        operation_type: Annotated[Optional[StrictStr], Field(description="the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. ")] = None,
        allowed_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        redacted_or_tokenized_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccessLogResults:
        """Get the access log for a single capsule

        Query the data-plane access log for this capsule. Results are returned in reverse chronological order. 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param start_from_id: which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. 
        :type start_from_id: str
        :param session: the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. 
        :type session: str
        :param location: the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. 
        :type location: str
        :param location_prefixed: a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. 
        :type location_prefixed: bool
        :param operation_type: the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. 
        :type operation_type: str
        :param allowed_tag: the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. 
        :type allowed_tag: str
        :param redacted_or_tokenized_tag: the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. 
        :type redacted_or_tokenized_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_query_access_log_single_capsule_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            start_from_id=start_from_id,
            session=session,
            location=location,
            location_prefixed=location_prefixed,
            operation_type=operation_type,
            allowed_tag=allowed_tag,
            redacted_or_tokenized_tag=redacted_or_tokenized_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessLogResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_query_access_log_single_capsule_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        start_from_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. ")] = None,
        session: Annotated[Optional[StrictStr], Field(description="the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. ")] = None,
        location: Annotated[Optional[StrictStr], Field(description="the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. ")] = None,
        location_prefixed: Annotated[Optional[StrictBool], Field(description="a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. ")] = None,
        operation_type: Annotated[Optional[StrictStr], Field(description="the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. ")] = None,
        allowed_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        redacted_or_tokenized_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccessLogResults]:
        """Get the access log for a single capsule

        Query the data-plane access log for this capsule. Results are returned in reverse chronological order. 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param start_from_id: which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. 
        :type start_from_id: str
        :param session: the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. 
        :type session: str
        :param location: the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. 
        :type location: str
        :param location_prefixed: a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. 
        :type location_prefixed: bool
        :param operation_type: the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. 
        :type operation_type: str
        :param allowed_tag: the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. 
        :type allowed_tag: str
        :param redacted_or_tokenized_tag: the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. 
        :type redacted_or_tokenized_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_query_access_log_single_capsule_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            start_from_id=start_from_id,
            session=session,
            location=location,
            location_prefixed=location_prefixed,
            operation_type=operation_type,
            allowed_tag=allowed_tag,
            redacted_or_tokenized_tag=redacted_or_tokenized_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessLogResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_query_access_log_single_capsule_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        start_date: Annotated[Optional[datetime], Field(description="the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. ")] = None,
        end_date: Annotated[Optional[datetime], Field(description="the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. ")] = None,
        num_results: Annotated[Optional[Annotated[int, Field(le=2000, strict=True, ge=10)]], Field(description="the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. ")] = None,
        start_from_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. ")] = None,
        session: Annotated[Optional[StrictStr], Field(description="the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. ")] = None,
        location: Annotated[Optional[StrictStr], Field(description="the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. ")] = None,
        location_prefixed: Annotated[Optional[StrictBool], Field(description="a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. ")] = None,
        operation_type: Annotated[Optional[StrictStr], Field(description="the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. ")] = None,
        allowed_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        redacted_or_tokenized_tag: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the access log for a single capsule

        Query the data-plane access log for this capsule. Results are returned in reverse chronological order. 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param start_date: the earlier date of the date range. As results are returned in reverse chronological order, this date corresponds with the end of the result set. 
        :type start_date: datetime
        :param end_date: the later date of the date range. As results are returned in reverse chronological order, this date corresponds with the beginning of the result set. If not specified, defaults to the current time. 
        :type end_date: datetime
        :param num_results: the number of results you would like returned. You may get more or less than this number, and it does not indicate anything about the availability of more records. Consult the returned \"has_more\" field to determine if there are more records available matching the filters and time range. 
        :type num_results: int
        :param start_from_id: which id to start from. This must be an ID of a record previously returned. The first result will have an ID less than this ID (because results are in reverse chronological order, and it is non-inclusive). You should omit this field if you are not continuing a paginated query. 
        :type start_from_id: str
        :param session: the session you would like to filter on. This will return results for only the provided session. If not specified, this field is ignored. 
        :type session: str
        :param location: the location you would like to filter on. This is a matched filter and will return results starting with the provided string. If not specified, this field is ignored. 
        :type location: str
        :param location_prefixed: a boolean indicator to indicate that the location you provided is a prefix or not. If this is set to true, then the filter provided in location is treated as a prefix. If not specified, this is treated as false. 
        :type location_prefixed: bool
        :param operation_type: the operation you would like to filter on. This will filter on the provided operation type and return all results using the provided operation type. If not specified, this field is ignored. 
        :type operation_type: str
        :param allowed_tag: the allow tag key you would like to filter on. This accepts tag key only and will return all allowed tag results matching the provided tag key. If not specified, this field is ignored. 
        :type allowed_tag: str
        :param redacted_or_tokenized_tag: the redacted or tokenized tag key you would like ot filter on. This accepts a tag key only and will return all redacted and tokenized tag key results matching the provided tag key. If not specified, this field is ignored. 
        :type redacted_or_tokenized_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_query_access_log_single_capsule_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            start_date=start_date,
            end_date=end_date,
            num_results=num_results,
            start_from_id=start_from_id,
            session=session,
            location=location,
            location_prefixed=location_prefixed,
            operation_type=operation_type,
            allowed_tag=allowed_tag,
            redacted_or_tokenized_tag=redacted_or_tokenized_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessLogResults",
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_query_access_log_single_capsule_serialize(
        self,
        domain_id,
        capsule_id,
        start_date,
        end_date,
        num_results,
        start_from_id,
        session,
        location,
        location_prefixed,
        operation_type,
        allowed_tag,
        redacted_or_tokenized_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        if capsule_id is not None:
            _path_params['capsuleID'] = capsule_id
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if num_results is not None:
            
            _query_params.append(('num_results', num_results))
            
        if start_from_id is not None:
            
            _query_params.append(('start_from_id', start_from_id))
            
        if session is not None:
            
            _query_params.append(('session', session))
            
        if location is not None:
            
            _query_params.append(('location', location))
            
        if location_prefixed is not None:
            
            _query_params.append(('location_prefixed', location_prefixed))
            
        if operation_type is not None:
            
            _query_params.append(('operation_type', operation_type))
            
        if allowed_tag is not None:
            
            _query_params.append(('allowed_tag', allowed_tag))
            
        if redacted_or_tokenized_tag is not None:
            
            _query_params.append(('redacted_or_tokenized_tag', redacted_or_tokenized_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/domains/{domainID}/capsules/{capsuleID}/log',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def domain_upsert_capsule_tags(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        domain_upsert_capsule_tags_request: DomainUpsertCapsuleTagsRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Upsert capsule-scope tags

        Upsert capsule-level tags. This is permitted even after a capsule is sealed. 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param domain_upsert_capsule_tags_request: (required)
        :type domain_upsert_capsule_tags_request: DomainUpsertCapsuleTagsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_upsert_capsule_tags_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            domain_upsert_capsule_tags_request=domain_upsert_capsule_tags_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def domain_upsert_capsule_tags_with_http_info(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        domain_upsert_capsule_tags_request: DomainUpsertCapsuleTagsRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Upsert capsule-scope tags

        Upsert capsule-level tags. This is permitted even after a capsule is sealed. 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param domain_upsert_capsule_tags_request: (required)
        :type domain_upsert_capsule_tags_request: DomainUpsertCapsuleTagsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_upsert_capsule_tags_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            domain_upsert_capsule_tags_request=domain_upsert_capsule_tags_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def domain_upsert_capsule_tags_without_preload_content(
        self,
        domain_id: Annotated[str, Field(strict=True)],
        capsule_id: Annotated[str, Field(strict=True)],
        domain_upsert_capsule_tags_request: DomainUpsertCapsuleTagsRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Upsert capsule-scope tags

        Upsert capsule-level tags. This is permitted even after a capsule is sealed. 

        :param domain_id: (required)
        :type domain_id: str
        :param capsule_id: (required)
        :type capsule_id: str
        :param domain_upsert_capsule_tags_request: (required)
        :type domain_upsert_capsule_tags_request: DomainUpsertCapsuleTagsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._domain_upsert_capsule_tags_serialize(
            domain_id=domain_id,
            capsule_id=capsule_id,
            domain_upsert_capsule_tags_request=domain_upsert_capsule_tags_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '308': None,
            '400': "InvalidRequestError",
            '401': "UnauthorizedError",
            '404': "ResourceNotFoundError",
            '409': "ConflictError",
            '412': "PreconditionFailedError",
            '429': "ResourceExhaustedError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _domain_upsert_capsule_tags_serialize(
        self,
        domain_id,
        capsule_id,
        domain_upsert_capsule_tags_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain_id is not None:
            _path_params['domainID'] = domain_id
        if capsule_id is not None:
            _path_params['capsuleID'] = capsule_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if domain_upsert_capsule_tags_request is not None:
            _body_params = domain_upsert_capsule_tags_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'domain_identity'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/domains/{domainID}/capsules/{capsuleID}/capsule-tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


