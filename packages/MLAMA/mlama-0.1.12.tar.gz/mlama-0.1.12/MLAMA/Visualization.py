# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fdbWbsZgYTqDMrbVlC0MVfjGy8HRutCm
"""

from pandas import read_csv
from pandas import DataFrame
from pandas import concat
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from .Models import replace_negatives

#as observed contains only test_y, so this works here with the prediction only??in case of task?
def create_visualization_df(WAVES, predictions, delay_list, visualization_columns, metrics_df, inFoldername_pre, task_name, filename):
  visualization_data = pd.DataFrame(columns=visualization_columns)

  for WAVE in  WAVES:
    waveID = WAVE.waveID
    for prediction_length in predictions:
      for delay in delay_list:
        print("prediction_length: ", prediction_length, "delay: ",delay, "Wave: ", waveID)
        #observed_data = metrics_df.loc[(metrics_df['wave'] == waveID) &  (metrics_df['prediction_length'] == prediction_length) &  (metrics_df['delay'] == delay)]['Observed'].values[0]
        xgb_data = metrics_df.loc[(metrics_df['wave'] == waveID) &  (metrics_df['prediction_length'] == prediction_length) &  (metrics_df['delay'] == delay)]['xgb_p'].values[0]
        arima_data = metrics_df.loc[(metrics_df['wave'] == waveID) &  (metrics_df['prediction_length'] == prediction_length) &  (metrics_df['delay'] == delay)]['arimap'].values[0]
        rf_data = metrics_df.loc[(metrics_df['wave'] == waveID) &  (metrics_df['prediction_length'] == prediction_length) &  (metrics_df['delay'] == delay)]['rf_pre'].values[0]

        xgb_df = pd.DataFrame(xgb_data).reset_index(drop = True)
        #observed_df = pd.DataFrame(observed_data).reset_index(drop = True)
        arima_df = pd.DataFrame(arima_data).reset_index(drop = True)
        rf_df = pd.DataFrame(rf_data).reset_index(drop = True)

        real_STAT = metric_row['Observed_fit_train_pred_test_STAT'].values[0]
        real_ML = metric_row['Observed_fit_train_pred_test_ML'].values[0]

        week_values_STAT = metric_row['weekSTAT'].values[0]
        week_values_ML = metric_row['weekML'].values[0]
        arima_df['week'] = week_values_STAT
        arima_df['Observed'] = real_STAT
        arima_df.columns = ["ARIMA", 'week', "Observed"]
        xgb_df['week'] = week_values_ML
        xgb_df['Observed'] = real_ML
        xgb_df.columns = ["XGBoost", 'week', "Observed"]

        rf_df['week'] = week_values_ML
        rf_df['Observed'] = real_ML
        rf_df.columns = ["RF", 'week', "Observed"]

        mid_merge = pd.merge(arima_df, xgb_df, on=['week', 'Observed'], how = 'inner')

        #print(mid_merge.head())

        task = pd.merge(mid_merge, rf_df, on=['week', 'Observed'], how = 'inner')
        #print(task.head())

        result = task#.reset_index()


        #xgb_df.columns = ['XGBoost']
        #arima_df.columns = ['ARIMA']
        #observed_df.columns = ['Observed']
        #rf_df.columns = ['RF']
        #frames = [observed_df, xgb_df, rf_df, arima_df]
        #result = pd.concat(frames, axis=1)

        result['Wave'] = waveID
        result['Delay'] = delay
        result['Length'] = prediction_length


        visualization_data = pd.concat([visualization_data, result])
        visualization_data.reset_index(drop=True, inplace=True)# so that previous redundant index resets

  print(visualization_data)
  visualization_data.to_csv(inFoldername_pre+task_name+'_model_predictions_'+filename)
  return visualization_data

def process_metrics_df(WAVE, frame, recent_week_count):#cloumn_name
  #print(frame)
  metrics_df = pd.concat(frame, axis = 1).tail(recent_week_count)
  #print(metrics_df.head())
  #metrics_df.columns = cloumn_name
  metrics_df.reset_index(drop=True)
  metrics_df.index = WAVE.get_wave_df().tail(32).index#to get the week as index
  metrics_df= metrics_df.applymap(replace_negatives)
  return metrics_df

def find_model_week_values_sum_delay(df, delay, weeks):
  """
  find values from the dataframe given delay for all weeks

  Args:
    df: the dataframe for a specific model
    delay: specific delay integer
    weeks: The list containing week values
  Returns:
    all_week_listTTT: Transposed according to week
    values: sum value for each week
  """
  all_week_listTT = pd.DataFrame()
  values = pd.DataFrame()
  all_week_list = df[delay]#correct
  all_week_listT = all_week_list.T
  for week in weeks:
    all_week_listTT[str(week+1)] = all_week_listT.apply(lambda x: x[0][week], axis = 1)#to get the weeks as column names
  all_week_listTTT = all_week_listTT.T
  values = all_week_listTT.sum()
  return all_week_listTTT,values