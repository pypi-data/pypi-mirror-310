syntax = "proto3";

package cz.proto.ingestion.v2;
option java_package = "cz.proto.ingestion.v2";

import "bucket_info.proto";
import "ddl.proto";
import "data_type.proto";
import "file_format_type.proto";
import "txn_manager.proto";

// common

message UserIdentifier {
  int64 instance_id = 1;
  string workspace = 2;
  string user_name = 3;
  int64 user_id = 4;
}

message Account {
  UserIdentifier user_ident = 1;
  string token = 2;
}

message TableIdentifier {
  int64 instance_id = 1;
  string workspace = 2;
  string schema_name = 3;
  string table_name = 4;
}

enum Code {
  SUCCESS = 0;
  FAILED = 1;
  THROTTLED = 2;
  INTERNAL_ERROR = 3;
  PRECHECK_FAILED = 4;
  PARTIALLY_SUCCESS = 5;
  STREAM_UNAVAILABLE = 6;
  NEED_REDIRECT = 7;
}

message ResponseStatus {
  Code code = 1;
  string error_message = 2;
  string request_id = 3;
}

// controller

message DataField {
  string name = 1;
  DataType type = 2;
}

message DistributionSpec {
  repeated uint32 field_ids = 1;
  repeated string hash_functions = 2;
  uint32 num_buckets = 3;
}

message PrimaryKeySpec {
  repeated uint32 field_ids = 1;
}

message PartitionSpec {
  repeated uint32 src_field_ids = 1;
}

message StreamSchema {
  repeated DataField data_fields = 1;
  DistributionSpec dist_spec = 2; // optional
  PrimaryKeySpec primary_key_spec = 3; // optional
  PartitionSpec partition_spec = 4; // optional
}

message CreateOrGetStreamRequest {
  Account account = 1;
  TableIdentifier table_ident = 2;
  uint32 num_tablets = 3;
}

message CreateOrGetStreamResponse {
  TableIdentifier table_ident = 1;
  StreamSchema data_schema = 2;
  bool already_exists = 3;
  ResponseStatus status = 4;
  bool require_commit = 5;
}

message CloseStreamRequest {
  Account account = 1;
  TableIdentifier table_ident = 2;
}

message CloseStreamResponse {
  ResponseStatus status = 1;
}

// BEGIN bulk load

enum BulkLoadStreamState {
  BL_CREATED = 0;
  BL_SEALED = 1;
  BL_COMMIT_SUBMITTED = 2;
  BL_COMMIT_SUCCESS = 3;
  BL_COMMIT_FAILED = 4;
  BL_CANCELLED = 5;
};

enum BulkLoadStreamOperation {
  BL_APPEND = 0;
  BL_OVERWRITE = 1;
  BL_UPSERT = 2;
}

message OssStagingPathInfo {
  string path = 1;
  string sts_ak_id = 3;
  string sts_ak_secret = 4;
  string sts_token = 5;
  string oss_endpoint = 6;
  string oss_internal_endpoint = 7;
  uint64 oss_expire_time = 8;
}

message CosStagingPathInfo {
  string path = 1;
  string sts_ak_id = 2;
  string sts_ak_secret = 3;
  string sts_token = 4;
  string cos_region = 5;
  uint64 cos_expire_time = 6;
}

message S3StagingPathInfo {
  string path = 1;
  string sts_ak_id = 2;
  string sts_ak_secret = 3;
  string sts_token = 4;
  string s3_region = 5;
  uint64 s3_expire_time = 6;
}

message GcsStagingPathInfo {
  string path = 1;
  string sts_ak_id = 2;     // unused
  string sts_ak_secret = 3; // unused
  string sts_token = 4;
  string gcs_region = 5;    // unused
  uint64 gcs_expire_time = 6;
}

message ObsStagingPathInfo {
  string path = 1;
  string sts_ak_id = 2;
  string sts_ak_secret = 3;
  string sts_token = 4;
  string obs_endpoint = 5;
  uint64 obs_expire_time = 6;
}

message TosStagingPathInfo {
  string path = 1;
  string sts_ak_id = 2;
  string sts_ak_secret = 3;
  string sts_token = 4;
  string tos_region = 5;
  uint64 tos_expire_time = 6;
}

message LocalStagingPathInfo {
  string path = 1;
}

message StagingPathInfo {
  oneof path_info {
    OssStagingPathInfo oss_path = 1;
    CosStagingPathInfo cos_path = 2;
    LocalStagingPathInfo local_path = 3;
    S3StagingPathInfo s3_path = 4;
    GcsStagingPathInfo gcs_path = 5;
    ObsStagingPathInfo obs_path = 6;
    TosStagingPathInfo tos_path = 7;
  }
}

message BulkLoadStreamInfo {
  string stream_id = 1;
  BulkLoadStreamState stream_state = 2;
  string sql_job_id = 3;
  TableIdentifier identifier = 4;
  BulkLoadStreamOperation operation = 5;
  string partition_spec = 6;
  repeated string record_keys = 7;
  StreamSchema stream_schema = 8;
  string sql_error_msg = 9;
  bool prefer_internal_endpoint = 10;
  // Encryption config of cloud object stores.
  // Use a map here as these options vary from cloud to cloud.
  map<string, string> encryption_options = 11;
}

message BulkLoadStreamWriterConfig {
  StagingPathInfo staging_path = 1;
  cz.proto.FileFormatType file_format = 2;
  int64 max_num_rows_per_file = 3;
  int64 max_size_in_bytes_per_file = 4;
  int64 max_string_bytes = 5;
  int64 max_binary_bytes = 6;
  int64 max_json_bytes = 7;
}

message CreateBulkLoadStreamRequest {
  Account account = 1;
  TableIdentifier identifier = 2;
  BulkLoadStreamOperation operation = 3;
  string partition_spec = 4;
  repeated string record_keys = 5;
  bool prefer_internal_endpoint = 6;
}

message CreateBulkLoadStreamResponse {
  ResponseStatus status = 1;
  BulkLoadStreamInfo info = 2;
}

message GetBulkLoadStreamRequest {
  Account account = 1;
  TableIdentifier identifier = 2;
  string stream_id = 3;
  bool need_table_meta = 4;
}

message GetBulkLoadStreamResponse {
  ResponseStatus status = 1;
  BulkLoadStreamInfo info = 2;
}

message CommitBulkLoadStreamRequest {
  Account account = 1;
  TableIdentifier identifier = 2;
  string stream_id = 3;

  string execute_workspace = 4;
  string execute_vc_name = 5;

  enum CommitMode {
    COMMIT_STREAM = 0;
    ABORT_STREAM = 1;
  }

  CommitMode commit_mode = 6;
  // Is spec_partition_ids required?
  repeated uint32 spec_partition_ids = 7; // if empty, will commit all finished partition
}

message CommitBulkLoadStreamResponse {
  ResponseStatus status = 1;
  BulkLoadStreamInfo info = 2;
}

message GetBulkLoadStreamStsTokenRequest {
  Account account = 1;
  TableIdentifier identifier = 2;
  string stream_id = 3;
}

message GetBulkLoadStreamStsTokenResponse {
  ResponseStatus status = 1;
  StagingPathInfo staging_path = 2;
}

message OpenBulkLoadStreamWriterRequest {
  Account account = 1;
  TableIdentifier identifier = 2;
  string stream_id = 3;
  uint32 partition_id = 4;
}

message OpenBulkLoadStreamWriterResponse {
  ResponseStatus status = 1;
  BulkLoadStreamWriterConfig config = 2;
}

message FinishBulkLoadStreamWriterRequest {
  Account account = 1;
  TableIdentifier identifier = 2;
  string stream_id = 3;
  uint32 partition_id = 4;
  repeated string written_files = 5;
  repeated uint64 written_lengths = 6;
}

message FinishBulkLoadStreamWriterResponse {
  ResponseStatus status = 1;
}

// END bulk load

enum ConnectMode {
  DIRECT = 0;
  GATEWAY = 1;
  GATEWAY_INTERNAL = 2;
  GATEWAY_DIRECT = 3;
  GATEWAY_DIRECT_ALL = 4;
}

message GetRouteWorkersRequest {
  TableIdentifier table_ident = 1;
  ConnectMode connect_mode = 2;
  repeated int64 tablet_id = 3;
  // Optional, set to true if the client needs to get the bucket ids of each tablet.
  bool need_bucket_ids = 4;
}

message HostPortTuple {
  string host = 1;
  int32 port = 2;
}

message GetRouteWorkersResponse {
  repeated HostPortTuple tuple = 1;
  repeated int64 tablet_id = 2;
  ResponseStatus status = 3;
  repeated cz.proto.BucketIds bucket_ids = 4;
}

message ServerTokenMap {
  map<int64, string> server_tokens = 1;
}

message ServerTokenList {
  repeated string server_token = 1;
  // A map of server tokens keyed by tablet id.
  // Used in favor of server_token for multi-tablet requests.
  repeated ServerTokenMap server_token_map = 2;
}

message CommitRequest {
  Account account = 1;
  repeated TableIdentifier table_ident = 2;
  // List of server tokens for connected tablet servers of each table in table_ident above.
  // If provided, the size of server_token_list must be the same as the size of table_ident
  // to achieve an one-to-one mapping. If one specific table does not have a server_token,
  // simply leave the corresponding server_token empty.
  optional ServerTokenList server_token_list = 3;
}

message CommitResponse {
  ResponseStatus status = 1;
  // unique id of this commit to be used in CheckCommitResultRequest.
  // If commit_id is 0 or not set, it means the commit already succeeded or failed.
  int64 commit_id = 2;
}

message CheckCommitResultRequest {
  Account account = 1;
  int64 commit_id = 2;
}

message CheckCommitResultResponse {
  ResponseStatus status = 1;
  bool finished = 2;
}

message RouteRule {
  string resource_id = 1;
  int64 resource_type = 2;  // IGS_STREAM = 0, CZ_WORKSPACE = 1, CZ_INSTANCE = 2
  string service_tag = 3;
}

message UpdateRouteRuleBroadcastRequest {
  RouteRule rule = 1;
}

message UpdateRouteRuleBroadcastResponse {
  ResponseStatus status = 1;
}

service IngestionControllerService {
  rpc CreateOrGetStream(CreateOrGetStreamRequest) returns (CreateOrGetStreamResponse);
  rpc CloseStream(CloseStreamRequest) returns (CloseStreamResponse);

  rpc GetRouteWorkers(GetRouteWorkersRequest) returns (GetRouteWorkersResponse);
  rpc Commit(CommitRequest) returns (CommitResponse);
  rpc AsyncCommit(CommitRequest) returns (CommitResponse);
  rpc CheckCommitResult(CheckCommitResultRequest) returns (CheckCommitResultResponse);

  rpc CreateBulkLoadStream(CreateBulkLoadStreamRequest) returns (CreateBulkLoadStreamResponse);
  rpc GetBulkLoadStream(GetBulkLoadStreamRequest) returns (GetBulkLoadStreamResponse);
  rpc CommitBulkLoadStream(CommitBulkLoadStreamRequest) returns (CommitBulkLoadStreamResponse);
  rpc OpenBulkLoadStreamWriter(OpenBulkLoadStreamWriterRequest) returns (OpenBulkLoadStreamWriterResponse);
  rpc FinishBulkLoadStreamWriter(FinishBulkLoadStreamWriterRequest) returns (FinishBulkLoadStreamWriterResponse);
  rpc GetBulkLoadStreamStsToken(GetBulkLoadStreamStsTokenRequest) returns (GetBulkLoadStreamStsTokenResponse);

  // internal
  rpc UpdateRouteRuleBroadcast(UpdateRouteRuleBroadcastRequest) returns (UpdateRouteRuleBroadcastResponse);

  // schema change
  rpc HandleSchemaChange(SchemaChangeRequest) returns (SchemaChangeResponse);
}

// worker

enum OperationType {
  UNKNOWN = 0;
  INSERT = 1;
  UPDATE = 2;
  DELETE = 3;
  UPSERT = 4;
  INSERT_IGNORE = 5;
  UPDATE_IGNORE = 6;
  DELETE_IGNORE = 7;
}

message OperationTypeList {
  repeated OperationType op_types = 1;
}

message DataBlock {
  bytes arrow_payload = 1;
  bytes is_set_bitmaps_payload = 2; // optional, (rows * cols) bits
  oneof op_type_info {
    OperationTypeList row_op_type_list = 3;
    OperationType block_op_type = 4;
  }
  uint32 num_rows = 5;  // data block row count
}

message MutateRowStatus {
  Code code = 1;
  string error_message = 2;
  int32 row_index = 3;
}

message MutateRequest {
  Account account = 1;
  TableIdentifier table_ident = 2;
  int64 batch_id = 3;
  int64 write_timestamp = 4;
  repeated DataField data_fields = 5;
  DataBlock data_block = 6;
  // A unique token for connected tablet server. Unavailable until the first successful mutate request.
  // It is used to prevent data loss on tablet restart and should not be changed during the session.
  // Optional for the 1st request, required for the following requests.
  string server_token = 7;
  // A map of server tokens keyed by tablet id.
  // Used in favor of server_token for multi-tablet requests.
  map<int64, string> server_tokens = 8;

  optional cz.proto.tp.DistributedTxnSnapshot txn_snapshot = 88;
}

message MutateResponse {
  int64 batch_id = 1;
  int64 num_rows = 2;
  ResponseStatus status = 3;
  repeated MutateRowStatus row_status_list = 4;
  string server_token = 5;  // Required
  map<int64, string> server_tokens = 6;  // Used in favor of server_token for multi-tablet requests.
}

message MultiMutateRequest {
  int64 batch_id = 2;
  int64 write_timestamp = 3;
  repeated MutateRequest mutate_requests = 4;
}

message MultiMutateResponse {
  int64 batch_id = 1;
  int64 num_rows = 2;
  ResponseStatus status = 3;
  repeated MutateResponse mutate_responses = 4;
}

service IngestionWorkerService {
  rpc Mutate(stream MutateRequest) returns (stream MutateResponse);
  rpc MultiMutate(stream MultiMutateRequest) returns (stream MultiMutateResponse);
}

message InternalDataBlock {
  DataBlock data_block = 1;
  repeated uint32 bucket_id_list = 2;
}

message BucketedDataBlockList {
  repeated DataBlock data_blocks = 1;
  repeated uint32 bucket_id_list = 2;
}

message TabletDataSet {
  int32 tablet_id = 1;
  oneof data {
    InternalDataBlock internal_data_block = 2;
    BucketedDataBlockList bucketed_data_block_list = 3;
  }
}

message MutateInternalRequest {
  TableIdentifier table_ident = 1;
  int64 batch_id = 2;
  int64 write_timestamp = 3;
  repeated DataField data_fields = 4;
  repeated TabletDataSet tablet_data_sets = 5;
  string server_token = 6;  // Optional for the 1st request, required for the following requests.

  optional cz.proto.tp.DistributedTxnSnapshot txn_snapshot = 88;
}

service IngestionWorkerInternalService {
  rpc MutateInternal(MutateInternalRequest) returns (MutateResponse);
}

// Schema Change
message SchemaChangeRequest {
  Account account = 1;
  TableIdentifier table_ident = 2;
  repeated cz.proto.access.TableChange updates = 3;
  repeated string ddlSql = 4;
  string server_token = 5;
}

message SchemaChangeResponse {
  ResponseStatus status = 1;
}

// Router
message GetControllerAddressRequest {
  int64 instance_id = 1;
  string workspace = 2;
  string schema = 3;
  string table = 4;
}

message GetControllerAddressResponse {
  ResponseStatus status = 1;
  string service_address = 2;
}

message UpdateRouteRuleRequest {
  RouteRule rule = 1;
}

message UpdateRouteRuleResponse {
  ResponseStatus status = 1;
}

message RemoveRouteRuleRequest {
  string resource_id = 1;
  int64 resource_type = 2;
}

message RemoveRouteRuleResponse {
  ResponseStatus status = 1;
}

message ClearRouteRuleRequest {
}

message ClearRouteRuleResponse {
  ResponseStatus status = 1;
}

message ChangeDefaultServiceRequest {
  string service_tag = 1;
}

message ChangeDefaultServiceResponse {
  ResponseStatus status = 1;
}

message ControllerServiceInfo {
  string service_tag = 1;
  string service_address = 2;
  bool default_service = 3;
  string build_info = 4;
}

message RegisterNewServiceRequest {
  ControllerServiceInfo service = 1;
}

message RegisterNewServiceResponse {
  ResponseStatus status = 1;
}

service IGSRouterService {
  rpc GetControllerAddress(GetControllerAddressRequest) returns (GetControllerAddressResponse);
  // route maintains api
  rpc UpdateRouteRule(UpdateRouteRuleRequest) returns (UpdateRouteRuleResponse);
  rpc RemoveRouteRule(RemoveRouteRuleRequest) returns (RemoveRouteRuleResponse);
  rpc ClearRouteRule(ClearRouteRuleRequest) returns (ClearRouteRuleResponse);
  rpc ChangeDefaultService(ChangeDefaultServiceRequest) returns (ChangeDefaultServiceResponse);
  // controller will call this api to register to router
  rpc RegisterNewService(RegisterNewServiceRequest) returns (RegisterNewServiceResponse);
}
