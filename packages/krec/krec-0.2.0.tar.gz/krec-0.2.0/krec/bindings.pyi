# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing

class ActuatorCommand:
    r"""
    Command for an actuator
    """
    actuator_id: int
    position: float
    velocity: float
    torque: float
    def __new__(cls,actuator_id,position = ...,velocity = ...,torque = ...,values = ...): ...
    def __repr__(self) -> str:
        ...

    def set_position(self, value:float) -> None:
        ...

    def set_velocity(self, value:float) -> None:
        ...

    def set_torque(self, value:float) -> None:
        ...


class ActuatorConfig:
    r"""
    Configuration for an actuator
    """
    actuator_id: int
    kp: typing.Optional[float]
    kd: typing.Optional[float]
    ki: typing.Optional[float]
    max_torque: typing.Optional[float]
    name: typing.Optional[str]
    def __new__(cls,actuator_id,kp = ...,kd = ...,ki = ...,max_torque = ...,name = ...,values = ...): ...
    def __repr__(self) -> str:
        ...

    def set_kp(self, value:typing.Optional[float]) -> None:
        ...

    def set_kd(self, value:typing.Optional[float]) -> None:
        ...

    def set_ki(self, value:typing.Optional[float]) -> None:
        ...

    def set_max_torque(self, value:typing.Optional[float]) -> None:
        ...

    def set_name(self, value:typing.Optional[str]) -> None:
        ...


class ActuatorState:
    r"""
    State information for a single actuator
    """
    actuator_id: int
    online: bool
    position: typing.Optional[float]
    velocity: typing.Optional[float]
    torque: typing.Optional[float]
    temperature: typing.Optional[float]
    voltage: typing.Optional[float]
    current: typing.Optional[float]
    def __new__(cls,actuator_id,online = ...,position = ...,velocity = ...,torque = ...,temperature = ...,voltage = ...,current = ...,values = ...): ...
    def __repr__(self) -> str:
        ...

    def set_online(self, value:bool) -> None:
        ...

    def set_position(self, value:typing.Optional[float]) -> None:
        ...

    def set_velocity(self, value:typing.Optional[float]) -> None:
        ...

    def set_torque(self, value:typing.Optional[float]) -> None:
        ...

    def set_temperature(self, value:typing.Optional[float]) -> None:
        ...

    def set_voltage(self, value:typing.Optional[float]) -> None:
        ...

    def set_current(self, value:typing.Optional[float]) -> None:
        ...


class FrameIterator:
    r"""
    Iterator for frames
    """
    def __iter__(self) -> FrameIterator:
        ...

    def __next__(self) -> typing.Optional[KRecFrame]:
        ...


class IMUQuaternion:
    r"""
    A quaternion representing 3D rotation
    """
    x: float
    y: float
    z: float
    w: float
    def __new__(cls,x = ...,y = ...,z = ...,w = ...,values = ...): ...
    def __repr__(self) -> str:
        ...


class IMUValues:
    r"""
    IMU sensor values including acceleration, gyroscope, and orientation data
    """
    accel: typing.Optional[Vec3]
    gyro: typing.Optional[Vec3]
    quaternion: typing.Optional[IMUQuaternion]
    def __new__(cls,accel = ...,gyro = ...,mag = ...,quaternion = ...,values = ...): ...
    def __repr__(self) -> str:
        ...

    def set_accel(self, value:typing.Optional[Vec3]) -> None:
        ...

    def set_gyro(self, value:typing.Optional[Vec3]) -> None:
        ...

    def set_quaternion(self, value:typing.Optional[IMUQuaternion]) -> None:
        ...


class KRec:
    frame_count: int
    header: KRecHeader
    def __new__(cls,header:KRecHeader): ...
    def get_frame(self, index:int) -> KRecFrame:
        r"""
        Get a specific frame by index
        """
        ...

    def get_frames(self) -> list[KRecFrame]:
        r"""
        Get all frames
        """
        ...

    def add_frame(self, frame:KRecFrame) -> None:
        r"""
        Add a frame to the recording
        """
        ...

    def remove_frame(self, index:int) -> None:
        r"""
        Remove a frame at the specified index
        """
        ...

    def clear_frames(self) -> None:
        r"""
        Clear all frames
        """
        ...

    def __getitem__(self, index:int) -> KRecFrame:
        r"""
        Get a frame by index (Python [] operator)
        """
        ...

    def __len__(self) -> int:
        r"""
        Get the length (Python len() function)
        """
        ...

    def __iter__(self) -> FrameIterator:
        r"""
        Iterator support for frames
        """
        ...

    def __repr__(self) -> str:
        ...

    def __str__(self) -> str:
        ...

    def display(self) -> str:
        r"""
        Returns a detailed string representation of the KRec contents
        """
        ...

    def display_frame(self, frame_number:int) -> str:
        r"""
        Returns a more detailed string representation of a specific frame
        """
        ...

    def save(self, path:str) -> None:
        ...

    @staticmethod
    def load(path:str) -> KRec:
        ...

    def combine_with_video(self, video_path:str, output_path:str) -> None:
        ...


class KRecFrame:
    def new(self, video_timestamp:typing.Optional[int], frame_number:typing.Optional[int], inference_step:typing.Optional[int], values:typing.Optional[typing.Any]) -> KRecFrame:
        ...

    def __repr__(self) -> str:
        ...

    def get_video_timestamp(self) -> int:
        ...

    def set_video_timestamp(self, value:int) -> None:
        ...

    def get_frame_number(self) -> int:
        ...

    def set_frame_number(self, value:int) -> None:
        ...

    def get_inference_step(self) -> int:
        ...

    def set_inference_step(self, value:int) -> None:
        ...

    def add_actuator_state(self, state:ActuatorState) -> None:
        ...

    def get_actuator_states(self) -> list[ActuatorState]:
        ...

    def clear_actuator_states(self) -> None:
        ...

    def set_actuator_commands(self, commands:typing.Sequence[ActuatorCommand]) -> None:
        ...

    def get_actuator_commands(self) -> list[ActuatorCommand]:
        ...

    def clear_actuator_commands(self) -> None:
        ...

    def add_actuator_command(self, command:ActuatorCommand) -> None:
        ...

    def has_actuator_commands(self) -> bool:
        ...

    def actuator_command_count(self) -> int:
        ...

    def set_imu_values(self, imu:typing.Optional[IMUValues]) -> None:
        ...

    def get_imu_values(self) -> typing.Optional[IMUValues]:
        ...

    def clear_imu_values(self) -> None:
        ...

    def has_imu_values(self) -> bool:
        ...

    def actuator_state_count(self) -> int:
        ...


class KRecHeader:
    def new(self, uuid:typing.Optional[str], task:typing.Optional[str], robot_platform:typing.Optional[str], robot_serial:typing.Optional[str], start_timestamp:typing.Optional[int], end_timestamp:typing.Optional[int], values:typing.Optional[typing.Any]) -> KRecHeader:
        ...

    def __repr__(self) -> str:
        ...

    def get_uuid(self) -> str:
        ...

    def set_uuid(self, value:str) -> None:
        ...

    def get_task(self) -> str:
        ...

    def set_task(self, value:str) -> None:
        ...

    def get_robot_platform(self) -> str:
        ...

    def set_robot_platform(self, value:str) -> None:
        ...

    def get_robot_serial(self) -> str:
        ...

    def set_robot_serial(self, value:str) -> None:
        ...

    def get_start_timestamp(self) -> int:
        ...

    def set_start_timestamp(self, value:int) -> None:
        ...

    def get_end_timestamp(self) -> int:
        ...

    def set_end_timestamp(self, value:int) -> None:
        ...

    def add_actuator_config(self, config:ActuatorConfig) -> None:
        ...

    def get_actuator_configs(self) -> list[ActuatorConfig]:
        ...

    def clear_actuator_configs(self) -> None:
        ...


class Vec3:
    r"""
    A 3D vector with x, y, z components
    """
    x: float
    y: float
    z: float
    def __new__(cls,x = ...,y = ...,z = ...,values = ...): ...
    def __repr__(self) -> str:
        ...


def combine_with_video(video_path:str,krec_path:str,output_path:str) -> None:
    ...

def extract_from_video(video_path:str,output_path:str) -> None:
    ...

