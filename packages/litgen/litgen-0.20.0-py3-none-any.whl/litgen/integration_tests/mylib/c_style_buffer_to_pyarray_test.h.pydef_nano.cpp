// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: c_style_buffer_to_pyarray_test.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/function.h>
#include "mylib_main/mylib.h"

namespace py = nanobind;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module_& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:c_style_buffer_to_pyarray_test.h>    ////////////////////
    m.def("add_inside_buffer",
        [](py::ndarray<uint8_t> & buffer, uint8_t number_to_add)
        {
            auto add_inside_buffer_adapt_c_buffers = [](py::ndarray<uint8_t> & buffer, uint8_t number_to_add)
            {
                // convert py::array to C standard buffer (mutable)
                void * buffer_from_pyarray = buffer.data();
                size_t buffer_count = buffer.shape(0);
                uint8_t buffer_type = buffer.dtype().code;
                auto expected_type_0 = static_cast<uint8_t>(py::dlpack::dtype_code::UInt);
                if (buffer_type != expected_type_0)
                    throw std::runtime_error(std::string(R"msg(
                            Bad type!  Expected a numpy array of native type:
                                        uint8_t *
                                    Which is equivalent to
                                        dtype_code::UInt
                                    (using py::ndarray::dtype().code as an id)
                        )msg"));

                add_inside_buffer(static_cast<uint8_t *>(buffer_from_pyarray), static_cast<size_t>(buffer_count), number_to_add);
            };

            add_inside_buffer_adapt_c_buffers(buffer, number_to_add);
        },
        py::arg("buffer"), py::arg("number_to_add"),
        " add_inside_buffer: modifies a buffer by adding a value to its elements\n Will be published in python as:\n -->    def add_inside_buffer(buffer: np.ndarray, number_to_add: int) -> None:\n Warning, the python function will accept only uint8 numpy arrays, and check it at runtime!");

    m.def("buffer_sum",
        [](const py::ndarray<uint8_t> & buffer, int stride = -1) -> int
        {
            auto buffer_sum_adapt_c_buffers = [](const py::ndarray<uint8_t> & buffer, int stride = -1) -> int
            {
                // convert py::array to C standard buffer (const)
                const void * buffer_from_pyarray = buffer.data();
                size_t buffer_count = buffer.shape(0);
                uint8_t buffer_type = buffer.dtype().code;
                auto expected_type_0 = static_cast<uint8_t>(py::dlpack::dtype_code::UInt);
                if (buffer_type != expected_type_0)
                    throw std::runtime_error(std::string(R"msg(
                            Bad type!  Expected a numpy array of native type:
                                        const uint8_t *
                                    Which is equivalent to
                                        dtype_code::UInt
                                    (using py::ndarray::dtype().code as an id)
                        )msg"));

                // process stride default value (which was a sizeof in C++)
                int buffer_stride = stride;
                if (buffer_stride == -1)
                    buffer_stride = (int)buffer.itemsize();

                auto lambda_result = buffer_sum(static_cast<const uint8_t *>(buffer_from_pyarray), static_cast<size_t>(buffer_count), static_cast<size_t>(buffer_stride));
                return lambda_result;
            };

            return buffer_sum_adapt_c_buffers(buffer, stride);
        },
        py::arg("buffer"), py::arg("stride") = -1,
        " buffer_sum: returns the sum of a *const* buffer\n Will be published in python as:\n -->    def buffer_sum(buffer: np.ndarray, stride: int = -1) -> int:");

    m.def("add_inside_two_buffers",
        [](py::ndarray<uint8_t> & buffer_1, py::ndarray<uint8_t> & buffer_2, uint8_t number_to_add)
        {
            auto add_inside_two_buffers_adapt_c_buffers = [](py::ndarray<uint8_t> & buffer_1, py::ndarray<uint8_t> & buffer_2, uint8_t number_to_add)
            {
                // convert py::array to C standard buffer (mutable)
                void * buffer_1_from_pyarray = buffer_1.data();
                size_t buffer_1_count = buffer_1.shape(0);
                uint8_t buffer_1_type = buffer_1.dtype().code;
                auto expected_type_0 = static_cast<uint8_t>(py::dlpack::dtype_code::UInt);
                if (buffer_1_type != expected_type_0)
                    throw std::runtime_error(std::string(R"msg(
                            Bad type!  Expected a numpy array of native type:
                                        uint8_t *
                                    Which is equivalent to
                                        dtype_code::UInt
                                    (using py::ndarray::dtype().code as an id)
                        )msg"));

                // convert py::array to C standard buffer (mutable)
                void * buffer_2_from_pyarray = buffer_2.data();
                size_t buffer_2_count = buffer_2.shape(0);
                uint8_t buffer_2_type = buffer_2.dtype().code;
                auto expected_type_1 = static_cast<uint8_t>(py::dlpack::dtype_code::UInt);
                if (buffer_2_type != expected_type_1)
                    throw std::runtime_error(std::string(R"msg(
                            Bad type!  Expected a numpy array of native type:
                                        uint8_t *
                                    Which is equivalent to
                                        dtype_code::UInt
                                    (using py::ndarray::dtype().code as an id)
                        )msg"));

                add_inside_two_buffers(static_cast<uint8_t *>(buffer_1_from_pyarray), static_cast<uint8_t *>(buffer_2_from_pyarray), static_cast<size_t>(buffer_2_count), number_to_add);
            };

            add_inside_two_buffers_adapt_c_buffers(buffer_1, buffer_2, number_to_add);
        },
        py::arg("buffer_1"), py::arg("buffer_2"), py::arg("number_to_add"),
        " add_inside_two_buffers: modifies two mutable buffers\n litgen will detect that this function uses two buffers of same size.\n Will be published in python as:\n -->    def add_inside_two_buffers(buffer_1: np.ndarray, buffer_2: np.ndarray, number_to_add: int) -> None:");
    ////////////////////    </generated_from:c_style_buffer_to_pyarray_test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
