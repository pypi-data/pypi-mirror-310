// ============================================================================
// This file was autogenerated
// It is presented side to side with its source: class_test.h
// It is not used in the compilation
//    (see integration_tests/bindings/pybind_mylib.cpp which contains the full binding
//     code, including this code)
// ============================================================================

#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/function.h>
#include "mylib_main/mylib.h"

namespace py = nanobind;

// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end


void py_init_module_mylib(py::module_& m)
{
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:class_test.h>    ////////////////////
    auto pyClassMyClass =
        py::class_<MyClass>
            (m, "MyClass", "This is the class doc. It will be published as MyClass.__doc__")
        .def(py::init<int, const std::string &>(),
            py::arg("factor") = 10, py::arg("message") = "hello")
        .def_rw("factor", &MyClass::factor, "")
        .def_rw("delta", &MyClass::delta, "")
        .def_rw("message", &MyClass::message, "")
        .def_rw("numbers", &MyClass::numbers, " By default, modifications from python are not propagated to C++ for stl containers\n (see https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html)")
        .def("append_number_from_cpp",
            &MyClass::append_number_from_cpp,
            py::arg("v"),
            "However you can call dedicated modifying methods")
        .def_prop_ro("values",
            [](MyClass &self) -> py::ndarray<int, py::numpy, py::shape<2>, py::c_contig>
            {
                return self.values;
            },
            "")
        .def_prop_ro("flags",
            [](MyClass &self) -> py::ndarray<bool, py::numpy, py::shape<3>, py::c_contig>
            {
                return self.flags;
            },
            "")
        .def_ro_static("const_static_value", &MyClass::const_static_value, "")
        .def_rw_static("static_value", &MyClass::static_value, "")
        .def("calc",
            &MyClass::calc,
            py::arg("x"),
            "calc: example of simple method")
        .def("set_message",
            &MyClass::set_message,
            py::arg("m"),
            "set_message: another example of simple method")
        .def_static("static_message",
            &MyClass::static_message, "Returns a static message")
        ;


    auto pyClassMySingletonClass =
        py::class_<MySingletonClass>
            (m, "MySingletonClass", " MySingletonClass: demonstrate how to instantiate a singleton\n - The instance method shall return with return_value_policy::reference\n - The destructor may be private")
        .def_rw("value", &MySingletonClass::value, "")
        .def(py::init<>())
        .def_static("instance",
            &MySingletonClass::instance, "// py::return_value_policy::reference")
        ;


    auto pyClassMyFinalClass =
        py::class_<MyFinalClass>
            (m, "MyFinalClass", py::is_final(), " This struct is final, and thus cannot be inherited from python\n(final class)")
        .def(py::init<>()) // implicit default constructor
        .def("foo",
            &MyFinalClass::foo)
        ;


    auto pyClassMyStructDynamic =
        py::class_<MyStructDynamic>
            (m, "MyStructDynamic", py::dynamic_attr(), " This class accepts dynamic attributes\n see autogenerate_mylib.py:\n     options.class_dynamic_attributes__regex = r\"Dynamic$\"")
        .def("__init__", []( MyStructDynamic *self,
        int cpp_member = 1)
        {
            new (self) MyStructDynamic();  // placement new
            auto r = self;
            r->cpp_member = cpp_member;
        },
        py::arg("cpp_member") = 1
        )
        .def_rw("cpp_member", &MyStructDynamic::cpp_member, "")
        ;


    auto pyClassMyStructWithNestedEnum =
        py::class_<MyStructWithNestedEnum>
            (m, "MyStructWithNestedEnum", "");

    { // inner classes & enums of MyStructWithNestedEnum
        auto pyEnumChoice =
            py::enum_<MyStructWithNestedEnum::Choice>(pyClassMyStructWithNestedEnum, "Choice", py::is_arithmetic(), "")
                .value("a", MyStructWithNestedEnum::Choice::A, "");
    } // end of inner classes & enums of MyStructWithNestedEnum

    pyClassMyStructWithNestedEnum
        .def(py::init<>()) // implicit default constructor
        .def("handle_choice",
            &MyStructWithNestedEnum::HandleChoice,
            py::arg("value") = MyStructWithNestedEnum::Choice::A,
            " The first param of this function uses the inner scope of this class!\n When building the bindings, we need to add MyStructWithNestedEnum::")
        ;
    ////////////////////    </generated_from:class_test.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
}
